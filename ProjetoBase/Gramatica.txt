
<Exp> ::= <LetAssign> | <Assign> | <Sum>

<LetAssign> ::= LET ID EQ <Exp>
<Assign>    ::= ID EQ <Exp>          

<Sum>     ::= <Product> ((PLUS | MINUS) <Product>)*
<Product> ::= <Unary>   ((MUL  | DIV  ) <Unary  >)*

<Unary> ::= (PLUS | MINUS)* <Pow>

<Pow> ::= <Primary> (POW <Unary>)?

<Primary>     ::= <Atom> <CallSuffix>*
<CallSuffix>  ::= LPAR [<ArgList>] RPAR
<ArgList>     ::= <Exp> (COMMA <Exp>)*

<Atom> ::= INT
         | FLOAT
         | STRING
         | ID
         | <ListExp>
         | <TupleExp>
         | LPAR <Exp> RPAR
         | <FuncLiteral>

<FuncLiteral> ::= FUNC LPAR [ID (COMMA ID)*] RPAR ARROW <Exp>

<ListExp>  ::= LSQUARE [ <Exp> (COMMA <Exp>)* ] RSQUARE
<TupleExp> ::= LPAR <Exp> (COMMA <Exp>)+ RPAR



PLUS é o +
MUL é o *
DIV é o /
MINUS é o -
POW é o ^
LPAR é o (
RPAR é o )
COMMA é ,
INT é um inteiro qualquer
FLOAT é um float qualquer
ID é qualquer identificador
LET é a palavra reservada let
STRING algo entre aspas
FUNC é a palavra reservada fn
ARROW é ->
